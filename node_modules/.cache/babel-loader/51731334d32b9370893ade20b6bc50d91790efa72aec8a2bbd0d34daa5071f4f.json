{"ast":null,"code":"import _objectSpread from\"C:/Users/Usuario/Desktop/Carpeta de Pruebas - Holberton/casse-web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{collection,addDoc,getDocs,query,where,orderBy,onSnapshot,doc,updateDoc,serverTimestamp}from'firebase/firestore';import{db}from'./firebase';export const messagesService={// Crear nueva conversación\nasync createConversation(participants,productId,productTitle){try{const conversationRef=await addDoc(collection(db,'conversations'),{participants,productId,productTitle,lastMessage:'',lastMessageTime:serverTimestamp(),createdAt:serverTimestamp()});return conversationRef.id;}catch(error){console.error('Error creating conversation:',error);throw error;}},// Obtener conversaciones del usuario\nasync getUserConversations(userId){try{const q=query(collection(db,'conversations'),where('participants','array-contains',userId),orderBy('lastMessageTime','desc'));const querySnapshot=await getDocs(q);return querySnapshot.docs.map(doc=>_objectSpread({id:doc.id},doc.data()));}catch(error){console.error('Error getting conversations:',error);throw error;}},// Escuchar conversaciones en tiempo real\nsubscribeToConversations(userId,callback){const q=query(collection(db,'conversations'),where('participants','array-contains',userId),orderBy('lastMessageTime','desc'));return onSnapshot(q,snapshot=>{const conversations=snapshot.docs.map(doc=>_objectSpread({id:doc.id},doc.data()));callback(conversations);});},// Enviar mensaje\nasync sendMessage(conversationId,senderId,senderName,message){try{// Agregar mensaje\nawait addDoc(collection(db,'messages'),{conversationId,senderId,senderName,message,timestamp:serverTimestamp(),read:false});// Actualizar última actividad de la conversación\nconst conversationRef=doc(db,'conversations',conversationId);await updateDoc(conversationRef,{lastMessage:message,lastMessageTime:serverTimestamp()});return true;}catch(error){console.error('Error sending message:',error);throw error;}},// Obtener mensajes de una conversación\nasync getMessages(conversationId){try{const q=query(collection(db,'messages'),where('conversationId','==',conversationId),orderBy('timestamp','asc'));const querySnapshot=await getDocs(q);return querySnapshot.docs.map(doc=>_objectSpread({id:doc.id},doc.data()));}catch(error){console.error('Error getting messages:',error);throw error;}},// Escuchar mensajes en tiempo real\nsubscribeToMessages(conversationId,callback){const q=query(collection(db,'messages'),where('conversationId','==',conversationId),orderBy('timestamp','asc'));return onSnapshot(q,snapshot=>{const messages=snapshot.docs.map(doc=>_objectSpread({id:doc.id},doc.data()));callback(messages);});},// Marcar mensajes como leídos\nasync markAsRead(conversationId,userId){try{const q=query(collection(db,'messages'),where('conversationId','==',conversationId),where('senderId','!=',userId),where('read','==',false));const querySnapshot=await getDocs(q);const batch=[];querySnapshot.docs.forEach(doc=>{batch.push(updateDoc(doc.ref,{read:true}));});await Promise.all(batch);return true;}catch(error){console.error('Error marking messages as read:',error);throw error;}}};","map":{"version":3,"names":["collection","addDoc","getDocs","query","where","orderBy","onSnapshot","doc","updateDoc","serverTimestamp","db","messagesService","createConversation","participants","productId","productTitle","conversationRef","lastMessage","lastMessageTime","createdAt","id","error","console","getUserConversations","userId","q","querySnapshot","docs","map","_objectSpread","data","subscribeToConversations","callback","snapshot","conversations","sendMessage","conversationId","senderId","senderName","message","timestamp","read","getMessages","subscribeToMessages","messages","markAsRead","batch","forEach","push","ref","Promise","all"],"sources":["C:/Users/Usuario/Desktop/Carpeta de Pruebas - Holberton/casse-web/src/services/messagesService.js"],"sourcesContent":["import { \n  collection, \n  addDoc, \n  getDocs, \n  query, \n  where, \n  orderBy, \n  onSnapshot,\n  doc,\n  updateDoc,\n  serverTimestamp\n} from 'firebase/firestore';\nimport { db } from './firebase';\n\nexport const messagesService = {\n  // Crear nueva conversación\n  async createConversation(participants, productId, productTitle) {\n    try {\n      const conversationRef = await addDoc(collection(db, 'conversations'), {\n        participants,\n        productId,\n        productTitle,\n        lastMessage: '',\n        lastMessageTime: serverTimestamp(),\n        createdAt: serverTimestamp()\n      });\n      return conversationRef.id;\n    } catch (error) {\n      console.error('Error creating conversation:', error);\n      throw error;\n    }\n  },\n\n  // Obtener conversaciones del usuario\n  async getUserConversations(userId) {\n    try {\n      const q = query(\n        collection(db, 'conversations'),\n        where('participants', 'array-contains', userId),\n        orderBy('lastMessageTime', 'desc')\n      );\n      \n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error getting conversations:', error);\n      throw error;\n    }\n  },\n\n  // Escuchar conversaciones en tiempo real\n  subscribeToConversations(userId, callback) {\n    const q = query(\n      collection(db, 'conversations'),\n      where('participants', 'array-contains', userId),\n      orderBy('lastMessageTime', 'desc')\n    );\n    \n    return onSnapshot(q, (snapshot) => {\n      const conversations = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      callback(conversations);\n    });\n  },\n\n  // Enviar mensaje\n  async sendMessage(conversationId, senderId, senderName, message) {\n    try {\n      // Agregar mensaje\n      await addDoc(collection(db, 'messages'), {\n        conversationId,\n        senderId,\n        senderName,\n        message,\n        timestamp: serverTimestamp(),\n        read: false\n      });\n\n      // Actualizar última actividad de la conversación\n      const conversationRef = doc(db, 'conversations', conversationId);\n      await updateDoc(conversationRef, {\n        lastMessage: message,\n        lastMessageTime: serverTimestamp()\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  },\n\n  // Obtener mensajes de una conversación\n  async getMessages(conversationId) {\n    try {\n      const q = query(\n        collection(db, 'messages'),\n        where('conversationId', '==', conversationId),\n        orderBy('timestamp', 'asc')\n      );\n      \n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error getting messages:', error);\n      throw error;\n    }\n  },\n\n  // Escuchar mensajes en tiempo real\n  subscribeToMessages(conversationId, callback) {\n    const q = query(\n      collection(db, 'messages'),\n      where('conversationId', '==', conversationId),\n      orderBy('timestamp', 'asc')\n    );\n    \n    return onSnapshot(q, (snapshot) => {\n      const messages = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      callback(messages);\n    });\n  },\n\n  // Marcar mensajes como leídos\n  async markAsRead(conversationId, userId) {\n    try {\n      const q = query(\n        collection(db, 'messages'),\n        where('conversationId', '==', conversationId),\n        where('senderId', '!=', userId),\n        where('read', '==', false)\n      );\n      \n      const querySnapshot = await getDocs(q);\n      const batch = [];\n      \n      querySnapshot.docs.forEach(doc => {\n        batch.push(updateDoc(doc.ref, { read: true }));\n      });\n      \n      await Promise.all(batch);\n      return true;\n    } catch (error) {\n      console.error('Error marking messages as read:', error);\n      throw error;\n    }\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}